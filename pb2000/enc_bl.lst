HD61700 ASSEMBLER Rev 0.43 - ASSEMBLY LIST OF [enc_bl.asm]
00001:0000            ; base/org are meaningless in inline code, but keep the compiler happy
00002:0000            BASE:        EQU     &H7000
00003:0000                         START   here
00004:7000                         ORG     BASE
00005:7000            here:        
00006:7000            
00007:7000  9E16                   gre     IX,$22                ; save IX
00008:7002            ; c: $12, n: $13, i: $14,mac: $15,mic:$16; $10..$11 = helpers
00009:7002            ; $0..$1 = pkt, $2..$3 = cmap, $4..$5 = wbuf; $6..$7 = spos, $8..$9 = len
00010:7002  EA00E0                 ldim    $0,(IX+$31),8         ; load first 4 parameters into $0...$7
00011:7005  A808                   ldw     $8,(IX+$31)           ; load 5th parameter (len) into $8..$9
00012:7007  886006                 adw     $0,$6                 ; add offset (spos) to packet address
00013:700A  9640                   pre     IZ,$0                 ; put packet data address into IZ, buf
00014:700C  9602                   pre     IX,$2                 ; put check map address into IX, cmap
00015:700E            
00016:700E            ; clear check map
00017:700E  8F6E0E                 xrw     $14,$14               ; constant = 0
00018:7011  8F7010                 xrw     $16,$16               ; constant = 0
00019:7014  8F7212                 xrw     $18,$18               ; constant = 0
00020:7017  8F7414                 xrw     $20,$20               ; constant = 0
00021:701A            
00022:701A  420C04                 ld      $12,4                 ; loop counter
00023:701D            clloop:      
00024:701D            ; unrolled zeroing of the check map array
00025:701D  E20EE0                 stim    $14,(IX+$31),8        ; zero 8 bytes, IX+=8
00026:7020  E20EE0                 stim    $14,(IX+$31),8        ; zero 8 bytes, IX+=8
00027:7023  E20EE0                 stim    $14,(IX+$31),8        ; zero 8 bytes, IX+=8
00028:7026  E20EE0                 stim    $14,(IX+$31),8        ; zero 8 bytes, IX+=8
00029:7029  E20EE0                 stim    $14,(IX+$31),8        ; zero 8 bytes, IX+=8
00030:702C  E20EE0                 stim    $14,(IX+$31),8        ; zero 8 bytes, IX+=8
00031:702F  E20EE0                 stim    $14,(IX+$31),8        ; zero 8 bytes, IX+=8
00032:7032  E20EE0                 stim    $14,(IX+$31),8        ; zero 8 bytes, IX+=8
00033:7035  092C                   sb      $12,$30               ; decrement loop counter
00034:7037  B49B                   jr      nz,clloop             ; repeat until counter = 0
00035:7039            
00036:7039  9602                   pre     IX,$2                 ; reset IX, IX = cmap
00037:703B  826A08                 ldw     $10,$8                ; copy len into $10
00038:703E  420F00                 ld      $15,0                 ; mac = 0
00039:7041  4210FF                 ld      $16,&hff              ; mic = 255
00040:7044            
00041:7044            ; check and mark bytes present in block
00042:7044            cmloop:      
00043:7044  2B0C                   ldi     $12,(IZ+$31)          ; c = buf++
00044:7046  207E0C                 st      $30,(IX+$12)          ; cmap[c]=1
00045:7049  016F0C                 sbc     $15,$12               ; if c > mac
00046:704C  B104                   jr      nc,oldmac             ; nope
00047:704E  026F0C                 ld      $15,$12               ; mac = c
00048:7051            oldmac:      
00049:7051  016C10                 sbc     $12,$16               ; if mic < c
00050:7054  B104                   jr      nc,oldmic             ; nope
00051:7056  02700C                 ld      $16,$12               ; mic = c
00052:7059            oldmic:      
00053:7059  892A                   sbw     $10,$30               ; dec left
00054:705B  B498                   jr      nz,cmloop             ; any left? repeat
00055:705D            ; check if min byte is above max control character
00056:705D            miccheck:    
00057:705D  420C03                 ld      $12,3                 ; pb_mc
00058:7060  016C10                 sbc     $12,$16               ; if mic > pb_mc
00059:7063  B117                   jr      nc,maccheck           ; nope
00060:7065            ; yes: fill replacements with ffff (sub1=sub2 is checked on the other end)
00061:7065  9644                   pre     IZ,$4                 ; IZ = wbuf
00062:7067  D10AFFFF               ldw     $10,&hffff            ; $10 = ffff
00063:706B  A30A                   stiw    $10,(IZ+$31)          ; wbuf[0..1] = ffff, IZ = wbuf+4
00064:706D  A30A                   stiw    $10,(IZ+$31)          ; wbuf[2..3] = ffff, IZ = wbuf+4
00065:706F            ; now block copy the rest
00066:706F  9600                   pre     IX,$0                 ; ix (block start) = pkt + pos
00067:7071  824A                   ldw     $10,$0                ; $10 = pkt + pos
00068:7073  886A08                 adw     $10,$8                ; $10 = pkt+pos+len
00069:7076  962A                   pre     IY,$10                ; iy (block end) = pkt + pos + len
00070:7078  D8                     bup                           ; copy the block
00071:7079  B767                   jr      done                  ; the end
00072:707B            ; check if max byte is below 252 
00073:707B            maccheck:    
00074:707B  4210FC                 ld      $16,&hfc              ; tmp = 0xfc
00075:707E  016F10                 sbc     $15,$16               ; if mac < 0xfc
00076:7081  B110                   jr      nc,findsub            ; nope
00077:7083            ; yes: just use fc,fd,fe,ff as replacements
00078:7083  9644                   pre     IZ,$4                 ; IZ = wbuf
00079:7085  D10CFCFD               ldw     $12,&hfdfc            ; tmp, little endian
00080:7089  D10EFEFF               ldw     $14,&hfffe            ; tmp, little endian
00081:708D  E10C60                 stm     $12,(IZ+$31),4        ; wbuf[0..3] = fcfdfeff
00082:7090  B726                   jr      havesub               ;
00083:7092            ; find replacements
00084:7092            findsub:     
00085:7092  9644                   pre     IZ,$4                 ; IZ = wbuf
00086:7094  D10A0400               ldw     $10,4                 ; store 4
00087:7098  886A02                 adw     $10,$2                ; add cmap
00088:709B  960A                   pre     IX,$10                ; IX = cmap + 4
00089:709D  D10D0004               ldw     $13,&h0400            ; i = $14 = 4, n = $13 = 0
00090:70A1  420B04                 ld      $11,4                 ; constant
00091:70A4            fsloop:      
00092:70A4  2A0C                   ldi     $12,(IX+$31)          ; c = cmap++
00093:70A6  012C                   sbc     $12,$30               ; if c = 1
00094:70A8  B00A                   jr      z,cont                ; yes -> move on
00095:70AA  230E                   sti     $14,(IZ+$31)          ; wbuf++ = i
00096:70AC  082D                   ad      $13,$30               ; n++
00097:70AE  016D0B                 sbc     $13,$11               ; if n = 4
00098:70B1  B005                   jr      z,havesub             ; then break
00099:70B3            cont:        
00100:70B3  082E                   ad      $14,$30               ; i++
00101:70B5  B492                   jr      nz,fsloop             ; no carry = repeat
00102:70B7            ; we have idendified replacement bytes
00103:70B7            havesub:     
00104:70B7  D10A0400               ldw     $10,4                 ; constant
00105:70BB  886A04                 adw     $10,$4                ; add wbuf
00106:70BE  964A                   pre     IZ,$10                ; IZ = wbuf + 4;
00107:70C0  9600                   pre     IX,$0                 ; IX = pkt
00108:70C2  826A08                 ldw     $10,$8                ; loop counter = left
00109:70C5  420F04                 ld      $15,4                 ; constant
00110:70C8  420D00                 ld      $13,0                 ; clear $13 for later (byte->word with $12)
00111:70CB            subloop:     
00112:70CB  2A0C                   ldi     $12,(IX+$31)          ; c = pkt++
00113:70CD  016C0F                 sbc     $12,$15               ; if c < 4
00114:70D0  B10A                   jr      nc,nosub              ; else ->
00115:70D2  826804                 ldw     $8,$4                 ; $8 = wbuf
00116:70D5  88680C                 adw     $8,$12                ; $8 = wbuf + c
00117:70D8  116C08                 ld      $12,($8)              ; c = wbuf[c];
00118:70DB            nosub:       ; -> else
00119:70DB  230C                   sti     $12,(IZ+$31)          ; wbuf[4] = c, wbuf++
00120:70DD  892A                   sbw     $10,$30               ; if i left < 0
00121:70DF  B495                   jr      nz,subloop            ; then repeat
00122:70E1            done:        
00123:70E1  9616                   pre     IX,$22                ; restore IX
00124:70E3            

ASSEMBLY COMPLETE, NO ERRORS FOUND

HD61700 ASSEMBLER Rev 0.43 - MAP LIST OF [enc_bl.asm]
 LABEL           : ADDRESS(hex)  | LABEL           : ADDRESS(hex)
-------------------------------------------------------------------
 BASE            :   7000h     A | here            :   7000h      A
 clloop          :   701Dh     A | cmloop          :   7044h      A
 oldmac          :   7051h     A | oldmic          :   7059h      A
 miccheck        :   705Dh     A | maccheck        :   707Bh      A
 findsub         :   7092h     A | fsloop          :   70A4h      A
 cont            :   70B3h     A | havesub         :   70B7h      A
 subloop         :   70CBh     A | nosub           :   70DBh      A
 done            :   70E1h     A |

 START ADDRESS   = 7000h
 END ADDRESS     = 70E2h
 EXECUTE ADDRESS = 7000h
